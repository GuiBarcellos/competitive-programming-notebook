#include <bits/stdc++.h>
using namespace std;

const int MAXN = 1e5 + 5;

struct Point {
	int x, y, id;

	Point() {}

	Point(int x, int y) : x(x), y(y) {}

	// sort by y axis
	bool operator<(Point const& pt) const {
		return y < pt.y;
	}
};

long long dist(Point a, Point b) {
	long long dx = (a.x - b.y);
	long long dy = (a.y - b.y);

	return dx * dx + dy * dy;
}

int main() {
	int n; scanf("%d", &n);
	vector<Point> points(n);

	// just read everything
	for (int i = 0; i < n; i++) {
		scanf("%d%d", &points[i].x, &points[i].y);
		points[i].id = i;
	}
	
	// sort by x axis
	sort(points.begin(), points.end(), [](Point&a, Point& b) {return a.x < b.x;});
	
	set<Point> vis;
	vis.insert(points[0]);

	int last = 0; // last visited point
	long long h = LLONG_MAX; // best distance (squared to minimize errors)
	pair<int, int> best;

	// go through all points 
	for (int i = 1; i < n; i++) {
		// delete useless points (outside the range [i.x - h, i.x]
		while (last < i && points[i].x - points[last].x > h) vis.erase(points[last]), last++;

		// search for closest point on y range [i.y - h, i.y + h]
		for (auto it = vis.lower_bound(Point(0, points[i].y - h)); it != vis.end() && it->y-points[i].y < h; it++) {
			long long curDist = dist(points[i], *it);

			if (curDist < h) {
				h = curDist;
				best.fi = it->id;
				best.se = i;
			}
		}

		// point `i` is now visited
		vis.insert(points[i]);
	}

	printf("%d %d %.4lf\n", best.fi, best.se, sqrt(h));

	return 0;
}
